import { UnitMission } from "../game-ai/UnitMission"
import { makeStandardFactions } from "../game-creation/factionFactory"
import { Faction } from "../game-entities/Faction"
import { GameState } from "../game-entities/GameState"
import { Town } from "../game-entities/Town"
import { Unit } from "../game-entities/Unit"
import { UnitType, unitTypes } from "../game-entities/UnitType"
import { areSamePlace, pickAtRandom } from "../utility"

const tutuorialContent = {

    firstMove: {
        text: {
            english: "Welcome to conquest - your goal is found an empire and conquer the world, but first, lests explore a little! You start with three units - a settler, a worker and a warrior. To move your units, click on one of the tiles next to them. Give it a try!"
        }
    },
    nextMove: {
        text: {
            english: "Well done! Keep moving your units until they have all gone as far as they can go. When a unit has used all its moves for a turn, the next unit will become active. You can also switch units using the arrow buttons in the bottom right of the screen."
        }
    },
    factionWindow: {
        text: {
            english: "This is the Faction window. You can set the budget for your faction, see an overview of your towns and check your research progress."
        }
    },
    endOfTurn: {
        text: {
            english: "Now you have finished moving your all units, press the 'end turn' button. The other factions will move their units, then it will be your turn again."
        }
    },
    buildTown: {
        text: {
            english: "Let's build your first town with the settler! To select the settler, click the mode button to change from 'move units' to 'examine map', then clicking on the square with your settler in it to select your settler"
        }
    },
    settler: {
        text: {
            english: "Click the 'Move Units' mode button then press the 'build town' button above your settler. A unit needs at least one move left to take an action like building a town."
        }
    },
    townWindow: {
        text: {
            english: "The Town window is used to choose what the town will build and where its citizens work. Try clicking the small map to put your citizen to work in another square. Click 'close' when you are ready to leave."
        }
    },
    openingTownWindow: {
        text: {
            english: "You can view your towns by clicking on them with the mode set to 'Examine Map', or by right clicking if you have a mouse. Open the town window for your new town again."
        }
    },
    townWindowAgain: {
        text: {
            english: "Great! close the town window again to get back to the map. Use your units to explore the map for a while..."
        }
    },
    chooseFirstTech: {
        text: {
            english: "The research points generated by your towns are used to discover new technologies, which allow you to build better units and more buildings. Pick your first reasearch goal. You can ready about them by clicking the info icon if you like - this will open a new browser tab."
        }
    },
    firstTechChoosen: {
        text: {
            english: "Great! It can take several turn to research a new technology. You can check progress on the faction window."
        }
    },
    firstEnemy: {
        text: {
            english: "An enemy! Rival factions are a threat - attack this worker with your warrior by moving onto its square. It may take more than one turn to get there, so use 'end turn' when you have to."
        }
    },
    killedFirstEnemy: {
        text: {
            english: "You got him! Settlers and workers are non-combat units - they cannot attack and always loose when defending. When your warrior can move again, try to conquer the enemy town by moving him in to it."
        }
    },
    finished: {
        text: {
            english: "Congratulations - you've finished the tutorial! When you're ready, you should start a new game against real enemies..."
        }
    },
}

interface StateModificationFunction { (state: GameState): void }

class TutorialEvent {
    eventKeyName: string
    testToStart: (state: GameState) => boolean
    testToFinish: (state: GameState) => boolean
    hasStarted: boolean
    hasFinished: boolean
    prerequisteEvents: string[]
    triggeredStateChange: StateModificationFunction

    constructor(eventKeyName, testToStart, testToFinish, prerequisteEvents = [], triggeredStateChange = null) {

        this.eventKeyName = eventKeyName
        this.testToFinish = testToFinish
        this.testToStart = testToStart
        this.hasStarted = false
        this.hasFinished = false
        this.prerequisteEvents = prerequisteEvents || []
        this.triggeredStateChange = triggeredStateChange
    }

    static addFirstComputerFactionIfMissing() {
        return (state: GameState) => {
            if (state.factions.some(faction => faction.isComputerPlayer)) { return }
            const newFaction = makeStandardFactions(2)[1]
            state.factions.push(newFaction)
        }
    }

    static addNewUnitToGame(place, unitType: UnitType, faction: Faction, mission: UnitMission = null) {
        return (state: GameState) => {
            const newUnit = new Unit(unitType, faction, {
                x: place.x,
                y: place.y,
                missions: mission ? [mission] : []
            })
            state.units.push(newUnit)
        }
    }

    static addNewTownToGame(place, faction: Faction, townConfig: Object = {}) {
        return (state: GameState) => {
            const mapSquare = state.mapGrid[place.y][place.x]
            const newTown = new Town(faction, mapSquare, townConfig)
            state.towns.push(newTown)
        }
    }

    static checkNoUnitCanMove(playerFaction: Faction) {
        return (state: GameState) => { return !state.units.some(unit => unit.faction === playerFaction && !unit.canMakeNoMoreMoves(state)) }
    }

    static checkSomeUnitCanMove(playerFaction: Faction) {
        return (state: GameState) => { return state.units.some(unit => unit.faction === playerFaction && !unit.canMakeNoMoreMoves(state)) }
    }

    static checkPlayerHasATown(playerFaction: Faction) {
        return (state: GameState) => state.towns.some(town => town.faction == playerFaction)
    }
}


class TutorialState {
    enabled: boolean
    showing: boolean
    events: TutorialEvent[]
    playerFaction: Faction
    constructor(enabled: boolean, playerFaction: Faction) {
        this.enabled = enabled
        this.playerFaction = playerFaction
        this.showing = true

        this.events = [
            new TutorialEvent('firstMove',
                (state: GameState) => true,
                (state: GameState) => state.units.some(unit => unit.faction === this.playerFaction && (unit.remainingMoves < unit.type.moves)),
            ),
            new TutorialEvent('nextMove',
                (state: GameState) => state.units.some(unit => unit.faction === this.playerFaction && !unit.canMakeNoMoreMoves(state)),
                TutorialEvent.checkNoUnitCanMove(this.playerFaction),
                ['firstMove']
            ),

            new TutorialEvent('endOfTurn',
                TutorialEvent.checkNoUnitCanMove(this.playerFaction),
                TutorialEvent.checkSomeUnitCanMove(this.playerFaction),
            ),

            new TutorialEvent('factionWindow',
                (state: GameState) => !!state.factionWindowIsOpen,
                (state: GameState) => !state.factionWindowIsOpen,
                ['firstMove', 'nextMove', 'endOfTurn']
            ),

            new TutorialEvent('buildTown',
                TutorialEvent.checkSomeUnitCanMove(this.playerFaction),
                (state: GameState) => state.selectedUnit.type == unitTypes.settler,
                ['endOfTurn']
            ),
            new TutorialEvent('settler',
                (state: GameState) => state.selectedUnit.type == unitTypes.settler,
                (state: GameState) => TutorialEvent.checkPlayerHasATown(this.playerFaction),
                ['buildTown']
            ),
            new TutorialEvent('townWindow',
                (state: GameState) => !!state.openTown,
                (state: GameState) => !state.openTown,
                ['settler']
            ),
            new TutorialEvent('openingTownWindow',
                (state: GameState) => !state.openTown,
                (state: GameState) => !!state.openTown,
                ['townWindow']
            ),
            new TutorialEvent('townWindowAgain',
                (state: GameState) => !!state.openTown,
                (state: GameState) => !state.openTown,
                ['openingTownWindow']
            ),
            new TutorialEvent('chooseFirstTech',
                (state: GameState) => !!state.pendingDialogues.some(dialogue => dialogue.type === "TechDiscoveryChoice"),
                (state: GameState) => !state.pendingDialogues.some(dialogue => dialogue.type === "TechDiscoveryChoice"),
                []
            ),
            new TutorialEvent('firstTechChoosen',
                (state: GameState) => !state.pendingDialogues.some(dialogue => dialogue.type === "TechDiscoveryChoice"),
                (state: GameState) => true,
                ['chooseFirstTech']
            ),
            new TutorialEvent('firstEnemy',
                (state: GameState) => true,
                (state: GameState) => !state.units.some(unit => unit.faction !== this.playerFaction),
                ['townWindowAgain'],
                (state: GameState) => {

                    const emptySquareInView = this.playerFaction.getPlacesInSight(state.towns, state.units, state.mapGrid[0].length)
                        .filter(place => !state.mapGrid[place.y][place.x].isWater)
                        .filter(place => !state.towns.some(town => areSamePlace(town, place)))
                        .filter(place => !state.units.some(unit => areSamePlace(unit, place)))

                    const place = pickAtRandom(emptySquareInView)

                    TutorialEvent.addFirstComputerFactionIfMissing()(state)
                    TutorialEvent.addNewUnitToGame(place, unitTypes.worker, state.factions[1], new UnitMission('WAIT'))(state)
                    TutorialEvent.addNewTownToGame(place, state.factions[1], { population: 3 })(state)

                    this.playerFaction.updatePlacesInSightThisTurn(state)
                }
            ),
            new TutorialEvent('killedFirstEnemy',
                (state: GameState) => state.fallenUnits.some(unit => unit.faction !== this.playerFaction),
                (state: GameState) => !state.towns.some(town => town.faction !== this.playerFaction),
                ['firstEnemy']
            ),
            new TutorialEvent('finished',
                (state: GameState) => !state.towns.some(town => town.faction !== this.playerFaction),
                (state: GameState) => false,
                ['killedFirstEnemy']
            ),
        ]
    }

    get message() {
        const activeEvents = this.events.filter(event => event.hasStarted && !event.hasFinished)
        if (!activeEvents[0]) { return null }
        return tutuorialContent[activeEvents[0].eventKeyName] || null
    }

    updateEvents(state: GameState) {

        const prerequisteEventNotFinished = (eventKeyName) => {
            const event = this.events.filter(event => event.eventKeyName === eventKeyName)[0]
            if (!event) { return false }
            return !event.hasFinished
        }

        if (!this.enabled) { return }
        this.events.forEach(event => {

            if (event.hasFinished) { return }

            if (!event.hasStarted) {
                event.hasStarted = !event.prerequisteEvents.some(prerequisteEventNotFinished) && event.testToStart(state)
                if (event.hasStarted) {

                    if (event.triggeredStateChange) { event.triggeredStateChange(state) }
                    this.showing = true
                    return
                }
            }

            if (event.hasStarted) {
                event.hasFinished = event.testToFinish(state)
            }
        })
    }
}


export { TutorialState }